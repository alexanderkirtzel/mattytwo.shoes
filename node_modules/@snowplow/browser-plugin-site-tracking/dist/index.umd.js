/*!
 * Site tracking for Snowplow v3.1.6 (http://bit.ly/sp-js)
 * Copyright 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
 * Licensed under BSD-3-Clause
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.snowplowSiteTracking = {}));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || from);
    }

    /*!
     * Core functionality for Snowplow JavaScript trackers v3.1.6 (http://bit.ly/sp-js)
     * Copyright 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
     * Licensed under BSD-3-Clause
     */

    /*
     * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice, this
     *    list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *    this list of conditions and the following disclaimer in the documentation
     *    and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its
     *    contributors may be used to endorse or promote products derived from
     *    this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    function payloadBuilder() {
        var dict = {}, allJson = [], jsonForProcessing = [];
        var processor;
        var add = function (key, value) {
            if (value != null && value !== '') {
                // null also checks undefined
                dict[key] = value;
            }
        };
        var addDict = function (dict) {
            for (var key in dict) {
                if (Object.prototype.hasOwnProperty.call(dict, key)) {
                    add(key, dict[key]);
                }
            }
        };
        var addJson = function (keyIfEncoded, keyIfNotEncoded, json) {
            if (json && isNonEmptyJson(json)) {
                var jsonWithKeys = { keyIfEncoded: keyIfEncoded, keyIfNotEncoded: keyIfNotEncoded, json: json };
                jsonForProcessing.push(jsonWithKeys);
                allJson.push(jsonWithKeys);
            }
        };
        return {
            add: add,
            addDict: addDict,
            addJson: addJson,
            getPayload: function () { return dict; },
            getJson: function () { return allJson; },
            withJsonProcessor: function (jsonProcessor) {
                processor = jsonProcessor;
            },
            build: function () {
                processor === null || processor === void 0 ? void 0 : processor(this, jsonForProcessing);
                return dict;
            }
        };
    }
    /**
     * Is property a non-empty JSON?
     * @param property - Checks if object is non-empty json
     */
    function isNonEmptyJson(property) {
        if (!isJson(property)) {
            return false;
        }
        for (var key in property) {
            if (Object.prototype.hasOwnProperty.call(property, key)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Is property a JSON?
     * @param property - Checks if object is json
     */
    function isJson(property) {
        return (typeof property !== 'undefined' &&
            property !== null &&
            (property.constructor === {}.constructor || property.constructor === [].constructor));
    }

    /*
     * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice, this
     *    list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *    this list of conditions and the following disclaimer in the documentation
     *    and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its
     *    contributors may be used to endorse or promote products derived from
     *    this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    var label = 'Snowplow: ';
    var LOG_LEVEL;
    (function (LOG_LEVEL) {
        LOG_LEVEL[LOG_LEVEL["none"] = 0] = "none";
        LOG_LEVEL[LOG_LEVEL["error"] = 1] = "error";
        LOG_LEVEL[LOG_LEVEL["warn"] = 2] = "warn";
        LOG_LEVEL[LOG_LEVEL["debug"] = 3] = "debug";
        LOG_LEVEL[LOG_LEVEL["info"] = 4] = "info";
    })(LOG_LEVEL || (LOG_LEVEL = {}));
    var LOG = logger();
    function logger(logLevel) {
        if (logLevel === void 0) { logLevel = LOG_LEVEL.warn; }
        function setLogLevel(level) {
            if (LOG_LEVEL[level]) {
                logLevel = level;
            }
            else {
                logLevel = LOG_LEVEL.warn;
            }
        }
        /**
         * Log errors, with or without error object
         */
        function error(message, error) {
            var extraParams = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                extraParams[_i - 2] = arguments[_i];
            }
            if (logLevel >= LOG_LEVEL.error && typeof console !== 'undefined') {
                var logMsg = label + message + '\n';
                if (error) {
                    console.error.apply(console, __spreadArray([logMsg + '\n', error], extraParams));
                }
                else {
                    console.error.apply(console, __spreadArray([logMsg], extraParams));
                }
            }
        }
        /**
         * Log warnings, with or without error object
         */
        function warn(message, error) {
            var extraParams = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                extraParams[_i - 2] = arguments[_i];
            }
            if (logLevel >= LOG_LEVEL.warn && typeof console !== 'undefined') {
                var logMsg = label + message;
                if (error) {
                    console.warn.apply(console, __spreadArray([logMsg + '\n', error], extraParams));
                }
                else {
                    console.warn.apply(console, __spreadArray([logMsg], extraParams));
                }
            }
        }
        /**
         * Log debug messages
         */
        function debug(message) {
            var extraParams = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                extraParams[_i - 1] = arguments[_i];
            }
            if (logLevel >= LOG_LEVEL.debug && typeof console !== 'undefined') {
                console.debug.apply(console, __spreadArray([label + message], extraParams));
            }
        }
        /**
         * Log info messages
         */
        function info(message) {
            var extraParams = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                extraParams[_i - 1] = arguments[_i];
            }
            if (logLevel >= LOG_LEVEL.info && typeof console !== 'undefined') {
                console.info.apply(console, __spreadArray([label + message], extraParams));
            }
        }
        return { setLogLevel: setLogLevel, warn: warn, error: error, debug: debug, info: info };
    }
    /**
     * Build a self-describing event
     * A custom event type, allowing for an event to be tracked using your own custom schema
     * and a data object which conforms to the supplied schema
     *
     * @param event - Contains the properties and schema location for the event
     * @returns PayloadBuilder to be sent to {@link @snowplow/tracker-core#TrackerCore.track}
     */
    function buildSelfDescribingEvent(event) {
        var _a = event.event, schema = _a.schema, data = _a.data, pb = payloadBuilder();
        var ueJson = {
            schema: 'iglu:com.snowplowanalytics.snowplow/unstruct_event/jsonschema/1-0-0',
            data: { schema: schema, data: data }
        };
        pb.add('e', 'ue');
        pb.addJson('ue_px', 'ue_pr', ueJson);
        return pb;
    }
    /**
     * Build a Social Interaction Event
     * Social tracking will be used to track the way users interact
     * with Facebook, Twitter and Google + widgets
     * e.g. to capture “like this” or “tweet this” events.
     *
     * @param event - Contains the properties for the Social Interaction event
     * @returns PayloadBuilder to be sent to {@link @snowplow/tracker-core#TrackerCore.track}
     */
    function buildSocialInteraction(event) {
        var action = event.action, network = event.network, target = event.target;
        var eventJson = {
            schema: 'iglu:com.snowplowanalytics.snowplow/social_interaction/jsonschema/1-0-0',
            data: removeEmptyProperties({ action: action, network: network, target: target })
        };
        return buildSelfDescribingEvent({ event: eventJson });
    }
    /**
     * Build a Site Search Event
     * Used when a user performs a search action on a page
     *
     * @param event - Contains the properties for the Site Search event
     * @returns PayloadBuilder to be sent to {@link @snowplow/tracker-core#TrackerCore.track}
     */
    function buildSiteSearch(event) {
        var terms = event.terms, filters = event.filters, totalResults = event.totalResults, pageResults = event.pageResults;
        return buildSelfDescribingEvent({
            event: {
                schema: 'iglu:com.snowplowanalytics.snowplow/site_search/jsonschema/1-0-0',
                data: removeEmptyProperties({ terms: terms, filters: filters, totalResults: totalResults, pageResults: pageResults })
            }
        });
    }
    /**
     * Returns a copy of a JSON with undefined and null properties removed
     *
     * @param event - JSON object to clean
     * @param exemptFields - Set of fields which should not be removed even if empty
     * @returns A cleaned copy of eventJson
     */
    function removeEmptyProperties(event, exemptFields) {
        if (exemptFields === void 0) { exemptFields = {}; }
        var ret = {};
        for (var k in event) {
            if (exemptFields[k] || (event[k] !== null && typeof event[k] !== 'undefined')) {
                ret[k] = event[k];
            }
        }
        return ret;
    }

    /*!
     * Core functionality for Snowplow Browser trackers v3.1.6 (http://bit.ly/sp-js)
     * Copyright 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
     * Licensed under BSD-3-Clause
     */
    /**
     * Dispatch function to all specified trackers from the supplied collection
     *
     * @param trackers - An optional list of trackers to send the event to, or will send to all trackers
     * @param trackerCollection - The collection which the trackers will be selected from
     * @param fn - The function which will run against each tracker
     */
    function dispatchToTrackersInCollection(trackers, trackerCollection, fn) {
        try {
            getTrackersFromCollection(trackers !== null && trackers !== void 0 ? trackers : Object.keys(trackerCollection), trackerCollection).forEach(fn);
        }
        catch (ex) {
            LOG.error('Function failed', ex);
        }
    }
    function getTrackersFromCollection(trackerIds, trackerCollection) {
        var trackers = [];
        for (var _i = 0, trackerIds_1 = trackerIds; _i < trackerIds_1.length; _i++) {
            var id = trackerIds_1[_i];
            if (trackerCollection.hasOwnProperty(id)) {
                trackers.push(trackerCollection[id]);
            }
            else {
                LOG.warn(id + ' not configured');
            }
        }
        return trackers;
    }

    /*
     * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice, this
     *    list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *    this list of conditions and the following disclaimer in the documentation
     *    and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its
     *    contributors may be used to endorse or promote products derived from
     *    this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    var _trackers = {};
    function SiteTrackingPlugin() {
        return {
            activateBrowserPlugin: function (tracker) {
                _trackers[tracker.id] = tracker;
            }
        };
    }
    /**
     * Track a social interaction event
     *
     * @param event - The event information
     * @param trackers - The tracker identifiers which the event will be sent to
     */
    function trackSocialInteraction(event, trackers) {
        if (trackers === void 0) { trackers = Object.keys(_trackers); }
        dispatchToTrackersInCollection(trackers, _trackers, function (t) {
            t.core.track(buildSocialInteraction(event), event.context, event.timestamp);
        });
    }
    /**
     * Track an internal search event
     *
     * @param event - The event information
     * @param trackers - The tracker identifiers which the event will be sent to
     */
    function trackSiteSearch(event, trackers) {
        if (trackers === void 0) { trackers = Object.keys(_trackers); }
        dispatchToTrackersInCollection(trackers, _trackers, function (t) {
            t.core.track(buildSiteSearch(event), event.context, event.timestamp);
        });
    }
    /**
     * Track a timing event (such as the time taken for a resource to load)
     *
     * @param event - The event information
     * @param trackers - The tracker identifiers which the event will be sent to
     */
    function trackTiming(event, trackers) {
        if (trackers === void 0) { trackers = Object.keys(_trackers); }
        var category = event.category, variable = event.variable, timing = event.timing, label = event.label, context = event.context, timestamp = event.timestamp;
        dispatchToTrackersInCollection(trackers, _trackers, function (t) {
            t.core.track(buildSelfDescribingEvent({
                event: {
                    schema: 'iglu:com.snowplowanalytics.snowplow/timing/jsonschema/1-0-0',
                    data: {
                        category: category,
                        variable: variable,
                        timing: timing,
                        label: label
                    }
                }
            }), context, timestamp);
        });
    }

    exports.SiteTrackingPlugin = SiteTrackingPlugin;
    exports.trackSiteSearch = trackSiteSearch;
    exports.trackSocialInteraction = trackSocialInteraction;
    exports.trackTiming = trackTiming;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
