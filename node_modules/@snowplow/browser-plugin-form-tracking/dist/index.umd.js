/*!
 * Form tracking for Snowplow v3.1.6 (http://bit.ly/sp-js)
 * Copyright 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
 * Licensed under BSD-3-Clause
 */

(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.snowplowFormTracking = {}));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    function __spreadArray(to, from, pack) {
        if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
            if (ar || !(i in from)) {
                if (!ar) ar = Array.prototype.slice.call(from, 0, i);
                ar[i] = from[i];
            }
        }
        return to.concat(ar || from);
    }

    /*!
     * Core functionality for Snowplow JavaScript trackers v3.1.6 (http://bit.ly/sp-js)
     * Copyright 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
     * Licensed under BSD-3-Clause
     */

    /*
     * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice, this
     *    list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *    this list of conditions and the following disclaimer in the documentation
     *    and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its
     *    contributors may be used to endorse or promote products derived from
     *    this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    function payloadBuilder() {
        var dict = {}, allJson = [], jsonForProcessing = [];
        var processor;
        var add = function (key, value) {
            if (value != null && value !== '') {
                // null also checks undefined
                dict[key] = value;
            }
        };
        var addDict = function (dict) {
            for (var key in dict) {
                if (Object.prototype.hasOwnProperty.call(dict, key)) {
                    add(key, dict[key]);
                }
            }
        };
        var addJson = function (keyIfEncoded, keyIfNotEncoded, json) {
            if (json && isNonEmptyJson(json)) {
                var jsonWithKeys = { keyIfEncoded: keyIfEncoded, keyIfNotEncoded: keyIfNotEncoded, json: json };
                jsonForProcessing.push(jsonWithKeys);
                allJson.push(jsonWithKeys);
            }
        };
        return {
            add: add,
            addDict: addDict,
            addJson: addJson,
            getPayload: function () { return dict; },
            getJson: function () { return allJson; },
            withJsonProcessor: function (jsonProcessor) {
                processor = jsonProcessor;
            },
            build: function () {
                processor === null || processor === void 0 ? void 0 : processor(this, jsonForProcessing);
                return dict;
            }
        };
    }
    /**
     * Is property a non-empty JSON?
     * @param property - Checks if object is non-empty json
     */
    function isNonEmptyJson(property) {
        if (!isJson(property)) {
            return false;
        }
        for (var key in property) {
            if (Object.prototype.hasOwnProperty.call(property, key)) {
                return true;
            }
        }
        return false;
    }
    /**
     * Is property a JSON?
     * @param property - Checks if object is json
     */
    function isJson(property) {
        return (typeof property !== 'undefined' &&
            property !== null &&
            (property.constructor === {}.constructor || property.constructor === [].constructor));
    }

    /*
     * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice, this
     *    list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *    this list of conditions and the following disclaimer in the documentation
     *    and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its
     *    contributors may be used to endorse or promote products derived from
     *    this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    var label = 'Snowplow: ';
    var LOG_LEVEL;
    (function (LOG_LEVEL) {
        LOG_LEVEL[LOG_LEVEL["none"] = 0] = "none";
        LOG_LEVEL[LOG_LEVEL["error"] = 1] = "error";
        LOG_LEVEL[LOG_LEVEL["warn"] = 2] = "warn";
        LOG_LEVEL[LOG_LEVEL["debug"] = 3] = "debug";
        LOG_LEVEL[LOG_LEVEL["info"] = 4] = "info";
    })(LOG_LEVEL || (LOG_LEVEL = {}));
    logger();
    function logger(logLevel) {
        if (logLevel === void 0) { logLevel = LOG_LEVEL.warn; }
        function setLogLevel(level) {
            if (LOG_LEVEL[level]) {
                logLevel = level;
            }
            else {
                logLevel = LOG_LEVEL.warn;
            }
        }
        /**
         * Log errors, with or without error object
         */
        function error(message, error) {
            var extraParams = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                extraParams[_i - 2] = arguments[_i];
            }
            if (logLevel >= LOG_LEVEL.error && typeof console !== 'undefined') {
                var logMsg = label + message + '\n';
                if (error) {
                    console.error.apply(console, __spreadArray([logMsg + '\n', error], extraParams));
                }
                else {
                    console.error.apply(console, __spreadArray([logMsg], extraParams));
                }
            }
        }
        /**
         * Log warnings, with or without error object
         */
        function warn(message, error) {
            var extraParams = [];
            for (var _i = 2; _i < arguments.length; _i++) {
                extraParams[_i - 2] = arguments[_i];
            }
            if (logLevel >= LOG_LEVEL.warn && typeof console !== 'undefined') {
                var logMsg = label + message;
                if (error) {
                    console.warn.apply(console, __spreadArray([logMsg + '\n', error], extraParams));
                }
                else {
                    console.warn.apply(console, __spreadArray([logMsg], extraParams));
                }
            }
        }
        /**
         * Log debug messages
         */
        function debug(message) {
            var extraParams = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                extraParams[_i - 1] = arguments[_i];
            }
            if (logLevel >= LOG_LEVEL.debug && typeof console !== 'undefined') {
                console.debug.apply(console, __spreadArray([label + message], extraParams));
            }
        }
        /**
         * Log info messages
         */
        function info(message) {
            var extraParams = [];
            for (var _i = 1; _i < arguments.length; _i++) {
                extraParams[_i - 1] = arguments[_i];
            }
            if (logLevel >= LOG_LEVEL.info && typeof console !== 'undefined') {
                console.info.apply(console, __spreadArray([label + message], extraParams));
            }
        }
        return { setLogLevel: setLogLevel, warn: warn, error: error, debug: debug, info: info };
    }
    /**
     * Find dynamic context generating functions and return their results to be merged into the static contexts
     * Combine an array of unchanging contexts with the result of a context-creating function
     *
     * @param dynamicOrStaticContexts - Array of custom context Objects or custom context generating functions
     * @param Parameters - to pass to dynamic context callbacks
     * @returns An array of Self Describing JSON context
     */
    function resolveDynamicContext(dynamicOrStaticContexts) {
        var _a;
        var extraParams = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            extraParams[_i - 1] = arguments[_i];
        }
        return ((_a = dynamicOrStaticContexts === null || dynamicOrStaticContexts === void 0 ? void 0 : dynamicOrStaticContexts.map(function (context) {
            if (typeof context === 'function') {
                try {
                    return context.apply(void 0, extraParams);
                }
                catch (e) {
                    //TODO: provide warning
                    return undefined;
                }
            }
            else {
                return context;
            }
        }).filter(Boolean)) !== null && _a !== void 0 ? _a : []);
    }
    /**
     * Build a self-describing event
     * A custom event type, allowing for an event to be tracked using your own custom schema
     * and a data object which conforms to the supplied schema
     *
     * @param event - Contains the properties and schema location for the event
     * @returns PayloadBuilder to be sent to {@link @snowplow/tracker-core#TrackerCore.track}
     */
    function buildSelfDescribingEvent(event) {
        var _a = event.event, schema = _a.schema, data = _a.data, pb = payloadBuilder();
        var ueJson = {
            schema: 'iglu:com.snowplowanalytics.snowplow/unstruct_event/jsonschema/1-0-0',
            data: { schema: schema, data: data }
        };
        pb.add('e', 'ue');
        pb.addJson('ue_px', 'ue_pr', ueJson);
        return pb;
    }
    /**
     * Build a Form Focus or Change Form Event based on schema property
     * When a user focuses on a form element or when a user makes a
     * change to a form element.
     *
     * @param event - Contains the properties for the Form Focus or Change Form event
     * @returns PayloadBuilder to be sent to {@link @snowplow/tracker-core#TrackerCore.track}
     */
    function buildFormFocusOrChange(event) {
        var event_schema = '';
        var schema = event.schema, formId = event.formId, elementId = event.elementId, nodeName = event.nodeName, elementClasses = event.elementClasses, value = event.value, type = event.type;
        var event_data = { formId: formId, elementId: elementId, nodeName: nodeName, elementClasses: elementClasses, value: value };
        if (schema === 'change_form') {
            event_schema = 'iglu:com.snowplowanalytics.snowplow/change_form/jsonschema/1-0-0';
            event_data.type = type;
        }
        else if (schema === 'focus_form') {
            event_schema = 'iglu:com.snowplowanalytics.snowplow/focus_form/jsonschema/1-0-0';
            event_data.elementType = type;
        }
        return buildSelfDescribingEvent({
            event: {
                schema: event_schema,
                data: removeEmptyProperties(event_data, { value: true })
            }
        });
    }
    /**
     * Build a Form Submission Event
     * Used to track when a user submits a form
     *
     * @param event - Contains the properties for the Form Submission event
     * @returns PayloadBuilder to be sent to {@link @snowplow/tracker-core#TrackerCore.track}
     */
    function buildFormSubmission(event) {
        var formId = event.formId, formClasses = event.formClasses, elements = event.elements;
        return buildSelfDescribingEvent({
            event: {
                schema: 'iglu:com.snowplowanalytics.snowplow/submit_form/jsonschema/1-0-0',
                data: removeEmptyProperties({ formId: formId, formClasses: formClasses, elements: elements })
            }
        });
    }
    /**
     * Returns a copy of a JSON with undefined and null properties removed
     *
     * @param event - JSON object to clean
     * @param exemptFields - Set of fields which should not be removed even if empty
     * @returns A cleaned copy of eventJson
     */
    function removeEmptyProperties(event, exemptFields) {
        if (exemptFields === void 0) { exemptFields = {}; }
        var ret = {};
        for (var k in event) {
            if (exemptFields[k] || (event[k] !== null && typeof event[k] !== 'undefined')) {
                ret[k] = event[k];
            }
        }
        return ret;
    }

    /*!
     * Core functionality for Snowplow Browser trackers v3.1.6 (http://bit.ly/sp-js)
     * Copyright 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
     * Licensed under BSD-3-Clause
     */
    /**
     * Cross-browser helper function to add event handler
     */
    function addEventListener(element, eventType, eventHandler, options) {
        if (element.addEventListener) {
            element.addEventListener(eventType, eventHandler, options);
            return true;
        }
        // IE Support
        if (element.attachEvent) {
            return element.attachEvent('on' + eventType, eventHandler);
        }
        element['on' + eventType] = eventHandler;
    }
    /**
     * Convert a criterion object to a filter function
     *
     * @param object - criterion Either {allowlist: [array of allowable strings]}
     *                             or {denylist: [array of allowable strings]}
     *                             or {filter: function (elt) {return whether to track the element}
     * @param boolean - byClass Whether to allowlist/denylist based on an element's classes (for forms)
     *                        or name attribute (for fields)
     */
    function getFilterByClass(criterion) {
        // If the criterion argument is not an object, add listeners to all elements
        if (criterion == null || typeof criterion !== 'object' || Array.isArray(criterion)) {
            return function () {
                return true;
            };
        }
        var inclusive = Object.prototype.hasOwnProperty.call(criterion, 'allowlist');
        var specifiedClassesSet = getSpecifiedClassesSet(criterion);
        return getFilter(criterion, function (elt) {
            return checkClass(elt, specifiedClassesSet) === inclusive;
        });
    }
    /**
     * Convert a criterion object to a filter function
     *
     * @param object - criterion Either {allowlist: [array of allowable strings]}
     *                             or {denylist: [array of allowable strings]}
     *                             or {filter: function (elt) {return whether to track the element}
     */
    function getFilterByName(criterion) {
        // If the criterion argument is not an object, add listeners to all elements
        if (criterion == null || typeof criterion !== 'object' || Array.isArray(criterion)) {
            return function () {
                return true;
            };
        }
        var inclusive = criterion.hasOwnProperty('allowlist');
        var specifiedClassesSet = getSpecifiedClassesSet(criterion);
        return getFilter(criterion, function (elt) {
            return elt.name in specifiedClassesSet === inclusive;
        });
    }
    /**
     * List the classes of a DOM element without using elt.classList (for compatibility with IE 9)
     */
    function getCssClasses(elt) {
        return elt.className.match(/\S+/g) || [];
    }
    /**
     * Check whether an element has at least one class from a given list
     */
    function checkClass(elt, classList) {
        var classes = getCssClasses(elt);
        for (var _i = 0, classes_1 = classes; _i < classes_1.length; _i++) {
            var className = classes_1[_i];
            if (classList[className]) {
                return true;
            }
        }
        return false;
    }
    function getFilter(criterion, fallbackFilter) {
        if (criterion.hasOwnProperty('filter') && criterion.filter) {
            return criterion.filter;
        }
        return fallbackFilter;
    }
    function getSpecifiedClassesSet(criterion) {
        // Convert the array of classes to an object of the form {class1: true, class2: true, ...}
        var specifiedClassesSet = {};
        var specifiedClasses = criterion.allowlist || criterion.denylist;
        if (specifiedClasses) {
            if (!Array.isArray(specifiedClasses)) {
                specifiedClasses = [specifiedClasses];
            }
            for (var i = 0; i < specifiedClasses.length; i++) {
                specifiedClassesSet[specifiedClasses[i]] = true;
            }
        }
        return specifiedClassesSet;
    }

    /*
     * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice, this
     *    list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *    this list of conditions and the following disclaimer in the documentation
     *    and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its
     *    contributors may be used to endorse or promote products derived from
     *    this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    var innerElementTags = ['textarea', 'input', 'select'];
    var defaultTransformFn = function (x) { return x; };
    /*
     * Add submission event listeners to all form elements
     * Add value change event listeners to all mutable inner form elements
     */
    function addFormListeners(tracker, configuration) {
        var options = configuration.options, context = configuration.context, trackingMarker = tracker.id + 'form', config = getConfigurationForOptions(options);
        Array.prototype.slice.call(document.getElementsByTagName('form')).forEach(function (form) {
            if (config.formFilter(form) && !form[trackingMarker]) {
                Array.prototype.slice.call(innerElementTags).forEach(function (tagname) {
                    Array.prototype.slice.call(form.getElementsByTagName(tagname)).forEach(function (innerElement) {
                        if (config.fieldFilter(innerElement) &&
                            !innerElement[trackingMarker] &&
                            innerElement.type.toLowerCase() !== 'password') {
                            addEventListener(innerElement, 'focus', getFormChangeListener(tracker, config, 'focus_form', context), false);
                            addEventListener(innerElement, 'change', getFormChangeListener(tracker, config, 'change_form', context), false);
                            innerElement[trackingMarker] = true;
                        }
                    });
                });
                addEventListener(form, 'submit', getFormSubmissionListener(tracker, config, trackingMarker, context));
                form[trackingMarker] = true;
            }
        });
    }
    /*
     * Configures form tracking: which forms and fields will be tracked, and the context to attach
     */
    function getConfigurationForOptions(options) {
        if (options) {
            return {
                formFilter: getFilterByClass(options.forms),
                fieldFilter: getFilterByName(options.fields),
                fieldTransform: getTransform(options.fields)
            };
        }
        else {
            return {
                formFilter: function () { return true; },
                fieldFilter: function () { return true; },
                fieldTransform: defaultTransformFn
            };
        }
    }
    /**
     * Convert a criterion object to a transform function
     *
     * @param object - criterion {transform: function (elt) {return the result of transform function applied to element}
     */
    function getTransform(criterion) {
        if (criterion && Object.prototype.hasOwnProperty.call(criterion, 'transform')) {
            return criterion.transform;
        }
        return defaultTransformFn;
    }
    /*
     * Get an identifier for a form, input, textarea, or select element
     */
    function getElementIdentifier(elt) {
        var properties = ['name', 'id', 'type', 'nodeName'];
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var propName = properties_1[_i];
            if (elt[propName] != false && typeof elt[propName] === 'string') {
                return elt[propName];
            }
        }
        return null;
    }
    /*
     * Identifies the parent form in which an element is contained
     */
    function getParentFormIdentifier(elt) {
        while (elt && elt.nodeName && elt.nodeName.toUpperCase() !== 'HTML' && elt.nodeName.toUpperCase() !== 'FORM') {
            elt = elt.parentNode;
        }
        if (elt && elt.nodeName && elt.nodeName.toUpperCase() === 'FORM') {
            return getElementIdentifier(elt);
        }
        return null;
    }
    /*
     * Returns a list of the input, textarea, and select elements inside a form along with their values
     */
    function getInnerFormElements(trackingMarker, elt) {
        var innerElements = [];
        Array.prototype.slice.call(innerElementTags).forEach(function (tagname) {
            var trackedChildren = Array.prototype.slice.call(elt.getElementsByTagName(tagname)).filter(function (child) {
                return child.hasOwnProperty(trackingMarker);
            });
            Array.prototype.slice.call(trackedChildren).forEach(function (child) {
                if (child.type === 'submit') {
                    return;
                }
                var elementJson = {
                    name: getElementIdentifier(child),
                    value: child.value,
                    nodeName: child.nodeName
                };
                if (child.type && child.nodeName.toUpperCase() === 'INPUT') {
                    elementJson.type = child.type;
                }
                if ((child.type === 'checkbox' || child.type === 'radio') && !child.checked) {
                    elementJson.value = null;
                }
                innerElements.push(elementJson);
            });
        });
        return innerElements;
    }
    /*
     * Return function to handle form field change event
     */
    function getFormChangeListener(tracker, config, event_type, context) {
        return function (e) {
            var _a, _b;
            var elt = e.target;
            if (elt) {
                var type = elt.nodeName && elt.nodeName.toUpperCase() === 'INPUT' ? elt.type : null;
                var value = elt.type === 'checkbox' && !elt.checked ? null : config.fieldTransform(elt.value, elt);
                if (event_type === 'change_form' || (type !== 'checkbox' && type !== 'radio')) {
                    tracker.core.track(buildFormFocusOrChange({
                        schema: event_type,
                        formId: (_a = getParentFormIdentifier(elt)) !== null && _a !== void 0 ? _a : '',
                        elementId: (_b = getElementIdentifier(elt)) !== null && _b !== void 0 ? _b : '',
                        nodeName: elt.nodeName,
                        type: type,
                        elementClasses: getCssClasses(elt),
                        value: value !== null && value !== void 0 ? value : null
                    }), resolveDynamicContext(context, elt, type, value));
                }
            }
        };
    }
    /*
     * Return function to handle form submission event
     */
    function getFormSubmissionListener(tracker, config, trackingMarker, context) {
        return function (e) {
            var _a;
            var elt = e.target;
            var innerElements = getInnerFormElements(trackingMarker, elt);
            innerElements.forEach(function (innerElement) {
                var _a;
                innerElement.value = (_a = config.fieldTransform(innerElement.value, innerElement)) !== null && _a !== void 0 ? _a : innerElement.value;
            });
            tracker.core.track(buildFormSubmission({
                formId: (_a = getElementIdentifier(elt)) !== null && _a !== void 0 ? _a : '',
                formClasses: getCssClasses(elt),
                elements: innerElements
            }), resolveDynamicContext(context, elt, innerElements));
        };
    }

    /*
     * Copyright (c) 2021 Snowplow Analytics Ltd, 2010 Anthon Pang
     * All rights reserved.
     *
     * Redistribution and use in source and binary forms, with or without
     * modification, are permitted provided that the following conditions are met:
     *
     * 1. Redistributions of source code must retain the above copyright notice, this
     *    list of conditions and the following disclaimer.
     *
     * 2. Redistributions in binary form must reproduce the above copyright notice,
     *    this list of conditions and the following disclaimer in the documentation
     *    and/or other materials provided with the distribution.
     *
     * 3. Neither the name of the copyright holder nor the names of its
     *    contributors may be used to endorse or promote products derived from
     *    this software without specific prior written permission.
     *
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
     * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
     * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
     * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
     * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
     * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
     * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER
     * CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
     * OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
     * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
     */
    var _trackers = {};
    /**
     * A plugin which enabled automatic form tracking
     */
    function FormTrackingPlugin() {
        return {
            activateBrowserPlugin: function (tracker) {
                _trackers[tracker.id] = tracker;
            }
        };
    }
    /**
     * Enables automatic form tracking
     * An event will be fired when a form field is changed or a form submitted.
     * This can be called multiple times: only forms not already tracked will be tracked.
     *
     * @param configuration - The form tracking configuration
     * @param trackers - The tracker identifiers which the events will be sent to
     */
    function enableFormTracking(configuration, trackers) {
        if (configuration === void 0) { configuration = {}; }
        if (trackers === void 0) { trackers = Object.keys(_trackers); }
        trackers.forEach(function (t) {
            if (_trackers[t]) {
                if (_trackers[t].sharedState.hasLoaded) {
                    addFormListeners(_trackers[t], configuration);
                }
                else {
                    _trackers[t].sharedState.registeredOnLoadHandlers.push(function () {
                        addFormListeners(_trackers[t], configuration);
                    });
                }
            }
        });
    }

    exports.FormTrackingPlugin = FormTrackingPlugin;
    exports.enableFormTracking = enableFormTracking;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
//# sourceMappingURL=index.umd.js.map
